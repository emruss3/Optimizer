function F(e){const t=e.coordinates[0];let n=0;for(let a=0;a<t.length-1;a++)n+=t[a][0]*t[a+1][1],n-=t[a+1][0]*t[a][1];return Math.abs(n)/2}function R(...e){return e.length===0?{type:"Polygon",coordinates:[]}:e.length===1?e[0]:e.reduce((t,n)=>F(n)>F(t)?n:t)}function A(e,t){const n=B(e),a=B(t);return n.maxX<a.minX||n.minX>a.maxX||n.maxY<a.minY||n.minY>a.maxY,e}function k(e){return e.type==="Polygon"?[e]:e.type==="MultiPolygon"?e.coordinates.map(t=>({type:"Polygon",coordinates:t})):[]}function $(e){return e.sort((t,n)=>F(n)-F(t))}function v(e){const t=e.coordinates??[];if(!t.length)throw new Error("Polygon has no rings");let n=t[0],a=-1;for(const r of t){if(!r||r.length<4)continue;let o=0;for(let s=0;s<r.length-1;s++){const[c,u]=r[s],[d,m]=r[s+1];o+=c*m-d*u}const i=Math.abs(o/2);i>a&&(a=i,n=r)}return{type:"Polygon",coordinates:[n]}}function X(e){const t=e.coordinates?.[0];if(!t||t.length<4)throw new Error("Cannot bbox empty polygon");let n=1/0,a=1/0,r=-1/0,o=-1/0;for(const[i,s]of t)i<n&&(n=i),s<a&&(a=s),i>r&&(r=i),s>o&&(o=s);return[n,a,r,o]}function Y(e,t){const n=e.coordinates[0],a=t.coordinates[0],r=t.coordinates[1];let o=!1;for(let i=0,s=n.length-1;i<n.length;s=i++)n[i][1]>r!=n[s][1]>r&&a<(n[s][0]-n[i][0])*(r-n[i][1])/(n[s][1]-n[i][1])+n[i][0]&&(o=!o);return o}function B(e){const t=e.coordinates[0];let n=t[0][0],a=t[0][1],r=t[0][0],o=t[0][1];for(const i of t)n=Math.min(n,i[0]),a=Math.min(a,i[1]),r=Math.max(r,i[0]),o=Math.max(o,i[1]);return{minX:n,minY:a,maxX:r,maxY:o}}function C(e){const t=B(e),n=F(e);return{geometry:e,areaSqFt:n,bounds:t}}function q(e,t){const n=e.geometry,a=e.properties.areaSqFt||F(n),r=a*t.targetFAR,o=a*(t.targetCoveragePct/100),i=E(t.typology),s=[],c=B(n);F(n);const u=Math.ceil(Math.sqrt(t.numBuildings)),d=(c.maxX-c.minX)/u,m=(c.maxY-c.minY)/Math.ceil(t.numBuildings/u);let y=0,l=0;for(let p=0;p<Math.ceil(t.numBuildings/u)&&l<t.numBuildings;p++)for(let h=0;h<u&&l<t.numBuildings;h++){const g=c.minX+h*d+d/2,f=c.minY+p*m+m/2,x=r-y,P=t.numBuildings-l,b=x/P,S=Math.min(b,o-y);if(S>0){const w=z(l,g,f,d*.8,m*.8,S,i,t);s.push(w),y+=w.properties.areaSqFt||0,l++}}return s}function z(e,t,n,a,r,o,i,s){const c=a*r,u=Math.sqrt(o/c),d=a*u,m=r*u,y=D(t,n,d,m),l=d*m,p=Math.max(1,Math.floor(o/l)),h=p*10;return{id:`building_${e}`,type:"building",name:`Building ${e+1}`,geometry:y,properties:{areaSqFt:o,units:Math.floor(o/800),heightFt:Math.min(h,s.maxHeightFt||100),stories:p,use:I(i),color:T(i),rotation:0},metadata:{createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),source:"ai-generated"}}}function D(e,t,n,a){const r=n/2,o=a/2;return{type:"Polygon",coordinates:[[[e-r,t-o],[e+r,t-o],[e+r,t+o],[e-r,t+o],[e-r,t-o]]]}}function E(e){const t={bar:{id:"bar",name:"Bar Building",description:"Rectangular building with linear layout",shape:"rectangle",aspectRatio:3,defaultStories:3,defaultHeightFt:30},"L-shape":{id:"L-shape",name:"L-Shaped Building",description:"L-shaped building for corner lots",shape:"L-shape",aspectRatio:1.5,defaultStories:2,defaultHeightFt:20},podium:{id:"podium",name:"Podium Building",description:"Mixed-use with podium and tower",shape:"podium",aspectRatio:1,defaultStories:8,defaultHeightFt:80},custom:{id:"custom",name:"Custom Building",description:"Custom building design",shape:"custom",aspectRatio:1,defaultStories:2,defaultHeightFt:20}};return t[e]||t.bar}function I(e){switch(e.id){case"podium":return"mixed-use";case"bar":return"residential";case"L-shape":return"commercial";default:return"residential"}}function T(e){switch(e.id){case"podium":return"#8B5CF6";case"bar":return"#3B82F6";case"L-shape":return"#10B981";default:return"#6B7280"}}function H(e,t,n){const a=B(e);F(e);const r=t.stallWidthFt,o=t.stallDepthFt,i=t.aisleWidthFt,s=Math.floor((a.maxX-a.minX)/(r+i)),c=Math.floor((a.maxY-a.minY)/o),u=s*c,d=Math.min(n,u),m=[],y=[];let l=0,p=0,h=0;for(let f=0;f<c&&l<d;f++)for(let x=0;x<s&&l<d;x++){const P=a.minX+x*(r+i)+r/2,b=a.minY+f*o+o/2;if(Y(e,{coordinates:[P,b]})){let S="standard";p<Math.floor(d*t.adaPct/100)?(S="ada",p++):h<Math.floor(d*t.evPct/100)&&(S="ev",h++);const w={id:`stall_${l}`,x:P,y:b,width:r,height:o,angle:t.layoutAngle||0,type:S};m.push(w);const M={id:`parking_${l}`,type:"parking",name:`Parking Stall ${l+1}`,geometry:L(w),properties:{areaSqFt:r*o,parkingSpaces:1,stallType:S,adaCompliant:S==="ada",evReady:S==="ev"},metadata:{createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),source:"ai-generated"}};y.push(M),l++}}const g={totalStalls:l,adaStalls:p,evStalls:h,utilizationPct:l/n*100,overlapCount:0};return{stalls:m,features:y,metrics:g}}function L(e){const t=e.width/2,n=e.height/2;return{type:"Polygon",coordinates:[[[e.x-t,e.y-n],[e.x+t,e.y-n],[e.x+t,e.y+n],[e.x-t,e.y+n],[e.x-t,e.y-n]]]}}function W(e,t,n){const a=e.filter(g=>g.type==="building"),r=e.filter(g=>g.type==="parking"),o=e.filter(g=>g.type==="greenspace"),i=a.reduce((g,f)=>g+(f.properties.areaSqFt||0),0);r.reduce((g,f)=>g+(f.properties.areaSqFt||0),0);const s=o.reduce((g,f)=>g+(stall.properties.areaSqFt||0),0),c=i/t*100,u=i/t,d=s/t*100,m=a.reduce((g,f)=>g+(f.properties.units||0),0),y=r.reduce((g,f)=>g+(f.properties.parkingSpaces||0),0),l=m>0?y/m:0,p=[],h=[];return n.zoning.maxFar&&u>n.zoning.maxFar&&p.push(`FAR ${u.toFixed(2)} exceeds maximum ${n.zoning.maxFar}`),n.zoning.maxCoveragePct&&c>n.zoning.maxCoveragePct&&p.push(`Coverage ${c.toFixed(1)}% exceeds maximum ${n.zoning.maxCoveragePct}%`),n.zoning.minParkingRatio&&l<n.zoning.minParkingRatio&&p.push(`Parking ratio ${l.toFixed(2)} below minimum ${n.zoning.minParkingRatio}`),n.designParameters.targetFAR&&u<n.designParameters.targetFAR*.9&&h.push(`FAR ${u.toFixed(2)} below target ${n.designParameters.targetFAR}`),n.designParameters.targetCoveragePct&&c<n.designParameters.targetCoveragePct*.9&&h.push(`Coverage ${c.toFixed(1)}% below target ${n.designParameters.targetCoveragePct}%`),{totalBuiltSF:i,siteCoveragePct:c,achievedFAR:u,parkingRatio:l,openSpacePct:d,zoningCompliant:p.length===0,violations:p,warnings:h}}function _(e,t){const n=performance.now();try{const a=e.type==="Polygon"?v(e):v({type:"Polygon",coordinates:e.coordinates[0]||[]}),[r,o,i,s]=X(a),c=C(a),u=c.areaSqFt,d={targetFAR:t.designParameters.targetFAR,targetCoveragePct:t.designParameters.targetCoveragePct||50,typology:t.designParameters.buildingTypology,numBuildings:t.designParameters.numBuildings,maxHeightFt:t.zoning.maxFar?Math.floor(t.zoning.maxFar*10):void 0,minHeightFt:20},m=q(a,d,u),y=m.reduce((P,b)=>P+(b.properties.units||0),0),l=Math.ceil(y*t.designParameters.parking.targetRatio),p=H(a,t.designParameters.parking,l),h=[...m,...p.features],g=W(h,u,t),f=O(a,h,t);h.push(...f);const x=performance.now()-n;return{elements:h,metrics:g,envelope:c,processingTime:x}}catch(a){console.error("Error in generateSitePlan:",a);const r=performance.now()-n;return{elements:[],metrics:{totalBuiltSF:0,siteCoveragePct:0,achievedFAR:0,parkingRatio:0,openSpacePct:0,zoningCompliant:!1,violations:["Site plan generation failed"],warnings:[]},envelope:C(e),processingTime:r}}}function O(e,t,n){const a=[];try{const r=elementsToPolygons(t),o=R(...r),i=A(e,o),s=$(k(i)).slice(0,3),c=F(e)*.2;let u=0;for(let d=0;d<s.length&&u<c;d++){const m=s[d],y=F(m);if(y>100){const l=Math.min(y,c-u),p={id:`greenspace_${d+1}`,type:"greenspace",name:`Open Space ${d+1}`,geometry:m,properties:{areaSqFt:l,use:"landscaping"},metadata:{createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),source:"ai-generated"}};a.push(p),u+=l}}}catch(r){console.warn("Error generating greenspace geometry:",r);const i=F(e)*.2;if(i>100){const s={id:"greenspace_1",type:"greenspace",name:"Open Space",geometry:e,properties:{areaSqFt:i,use:"landscaping"},metadata:{createdAt:new Date().toISOString(),updatedAt:new Date().toISOString(),source:"ai-generated"}};a.push(s)}}return a}export{_ as generateSitePlan};
